#!/usr/bin/env python3

# Extracts information from MadGraph output to create a SLHA file with cross-section blocks
# 1) Run getSLHA to extract the information of the MadGraph output
# and generate a SLHA file containing the cross-sections

import sys,os
import logging
from collections import OrderedDict
import gzip
logger = logging.getLogger()



def getSLHAFile(banner,outputSLHA=None,pidList=[[1000024,1000022],[1000024,1000023],[-1000024,1000024],[1000022,1000023]]):
    """
    Uses the LHE file generated by MadGraph
    to generate an SLHA file which includes the XSECTION blocks.
    
    :param parser: ConfigParser object with all the parameters needed
    :param inputLHE: Path to the MadGraph LHE file.  
    :param outputSLHA: Name for the SLHA output. If not given, will use inputLHE+.slha.  
    :param pidList: List of final states PIDs for the process (assumes a single process),
                 used for defining the xsection block. If not given, will try to read it from
                 the process card.
                 
    
    :return: Path to the slha file
    """
    

    if outputSLHA is None:
        outputSLHA = banner[:banner.rfind('_banner.txt')]+'.slha'
    
    #Use MadGraph banner reader:
    madgraphPath = os.path.abspath('./MG5')
    sys.path.append(madgraphPath)
    from madgraph.various.banner import Banner
        
    #Create output dirs, if do not exist:
    try:
        os.makedirs(os.path.dirname(outputSLHA))
    except:
        pass    
    
    slhaFile = outputSLHA
    logger.debug('Creating SLHA file %s' %slhaFile)
    
    with open(banner,'r') as f:
        banner = Banner()
        banner.read_banner(f)
    
    #Check if input file is MG5 banner or SLHA file

    if not 'init' in banner or not 'slha' in banner:
        logger.error("Input file %s does not contain required data " %banner)
        return False
       
    # Collect necessary info:
    slhaData = banner['slha'] 
    finalStatesDict = {i+1 : sorted(pids) for i,pids in enumerate(pidList)}

    #Get total cross-section,number of events
    xsecTotal = banner.get_cross()
    if xsecTotal <= 0.:
        logger.error("Total cross-section is zero?")
        return False
    
    #Get sqrts and cross-section for each process:
    info = banner['init'].split('\n')[0].split()
    sqrts = eval(info[2]) + eval(info[3])
    pdgInitial = list(banner.get_pdg_beam())
    processXsecs = {}
    for l in banner['init'].split('\n')[1:]:
        if not l.strip() or l.strip()[0] == '<':
            continue
        vals = [eval(x) for x in l.split()]
        xsec,xsecErr,_,procID = vals
        if not procID in finalStatesDict:
            logger.error("Process ID %i not found in LHE file" %procID)
            return False
        if not procID in processXsecs:
            processXsecs[procID] = {'xsec (pb)' : xsec, 'xsecErr (pb)' : xsecErr}
        else:
            logger.error("Error reading subprocess cross-sections. The process ID = %i appears multiple times" %procID)
            return False


    #Check:
    if abs(xsecTotal - sum([x['xsec (pb)'] for x in processXsecs.values()]))/xsecTotal > 0.001:
        logger.error("Total cross-section does not agree with sum of subprocesses")
        return False 
    
    #Write SLHA file:
    slhaF = open(slhaFile,'w')
    slhaF.write(slhaData)
    slhaF.write('\n\n')
    processXsecs = OrderedDict(sorted(processXsecs.items(), 
                                      key=lambda proc: proc[1]['xsec (pb)'],reverse=True))
    for procID in processXsecs:
        finalStates = finalStatesDict[procID]
        xsec = processXsecs[procID]['xsec (pb)']
        xsecErr = processXsecs[procID]['xsecErr (pb)']
        comment = "# xsec unit: pb xsec error: %1.3e" %(xsecErr)
        xsecLine = "\nXSECTION %1.3e " %(sqrts)
        xsecLine += " ".join([str(pdg) for pdg in pdgInitial])
        xsecLine += " %i " %len(finalStates)
        xsecLine += " ".join([str(pdg) for pdg in finalStates])
        slhaF.write(xsecLine+' '+comment+' \n')        
        slhaF.write("  0  0  0  0  0  0  %1.4e ufo2slha 1.0\n" %xsec)    
    slhaF.close()
    
    logger.info("Finished SLHA creation")
    
    return slhaFile




if __name__ == "__main__":
    
    import argparse    
    ap = argparse.ArgumentParser( description=
            "Read a LHE event file generate by MG5 and convert it to a SLHA file with cross-section blocks." )
    ap.add_argument('-f', '--input',
            help='path to the banner input file.')
    ap.add_argument('-o', '--output',
            help='name of output (SLHA) file. If not given the input file name will be used.',default=None)
    ap.add_argument('-pids', '--pids',required=True,
            help='list of final state PIDs following the order defined in the process card (e.g. "[[-1000024,1000024],[1000022,1000023]]").',type=str)
    
    args = ap.parse_args()
    pids = eval(args.pids)
    output = getSLHAFile(args.input,args.output,pids)
            
    print("\n%s created.\n" %output)
